#!/usr/bin/perl
#
# Nagios plugin to check flow of messages to and from the Mainframe.

use strict;
use warnings;

use Getopt::Std;

$| = 1;

my $opt_str = "dhvot:H:S:";
my %opts;

my $maildir = "/var/lib/nagios/Maildir/Mainframe/new";
my $whitelist = "/var/lib/nagios/whitelist.msgs";
my $patt_subject = qr/Subject:\s+MESSAGE\ FILE\ NOTICE/x;
my $patt_message_id = qr/\s+(\d{2}[A-Z]{1}\d{5}.+)/x;

my $commandfile = "/usr/local/nagios/var/rw/nagios.cmd";
my $servicestatus = 0;
my $servicemessage = "";

sub printusage {
    print <<EOF;

Check messages flowing to and from the Mainframe.

Usage: $0 [-hvo] -t threshold -H service_host -S service_name

  -h : Print this help message.
  -v : Verbose output.
  -o : Output to STDOUT only.
  -t : Threshold value (in minutes).
  -H : Nagios service host.
  -S : Nagios service name.

EOF
    exit 3;
}

sub getoptions {
    getopts($opt_str, \%opts) or printusage();
    printusage() unless scalar %opts;
    printusage() if (! $opts{t} || ! $opts{H} || ! $opts{S} || $opts{h});
}

sub gettoday {
    my $path = shift;
    $path =~ s|/\z||;

    opendir my $dir, $path or die "Cannot open $path: $!\n";
    my @files = grep { ! /^\.\.?$/ && -f "$path/$_" } readdir($dir);
    closedir($dir);

    my @sorted;
    foreach (@files) { push(@sorted, "$path/$_") if ( -M "$path/$_" <= 1 ); }

    return @sorted;
}

sub searchfile {
    my $pattern = shift;
    my $logfile = shift;

    my $string = quotemeta $pattern;
    my $slurp;

    local $/ = undef;
    my $fh;
    open $fh, '<', "$logfile" or die "Cannot open $logfile: $!\n";
    $slurp = <$fh>;
    close($fh);

    return ($slurp =~ /$string/) ? 1 : 0;
}

sub writecommand {
    my $commandhost = shift;
    my $commandsvc = shift;
    my $status = shift;
    my $message = shift;

    my $extcmd = sprintf("[%d] PROCESS_SERVICE_CHECK_RESULT;%s;%s;%d;%s\n",
        time(), $commandhost, $commandsvc, $status, $message);

    my $fh;
    open $fh, '>', "$commandfile" or die "Cannot open $commandfile: $!\n";
    print $fh $extcmd;
    close($fh);
}

### main()

getoptions();

my $threshold = int($opts{t});
$threshold *= 60;

if ($opts{d}) {
    $maildir = "var/lib/nagios/Maildir/Mainframe/new/";
    $whitelist = "var/lib/nagios/whitelist.msgs";
    $commandfile = "usr/local/nagios/var/rw/nagios.cmd";
}

my $commandhost = $opts{H};
my $commandsvc = $opts{S};

my @skipped;
my @msg_ids;
my %msg_hash;
my @no_pairs;

foreach (gettoday($maildir)) {
    my $mtime = (stat($_))[9];
    my $stime = time();
    my $fn = $_;
    if ( ($stime - $mtime) < $threshold ) {
        push(@skipped, $fn);
        next;
    }
    open my $fh, '<',  "$fn" or die "Cannot open $fn: $!\n";
    while (<$fh>) {
        if (/$patt_subject/) {
            while (<$fh>) {
                push(@msg_ids, $1) if (/$patt_message_id/);
            }
        }
    }
    close($fh);
}

$msg_hash{$_}++ foreach @msg_ids;

foreach (keys %msg_hash) {
    if ( -e $whitelist ) {
        if ( searchfile($_, $whitelist) ) {
            $msg_hash{$_ . " [WHITELISTED]"} = delete $msg_hash{$_};
            next;
        }
    }
    push(@no_pairs, $_) if ($msg_hash{$_} eq '1');
}

if ($opts{v}) {
    printf "Threshold: %d\n", $threshold;
    printf "Maildir: %s\n", $maildir;
    if (@skipped) {
        printf "\nSkipped (less than threshold):\n";
        printf "%s\n", $_ foreach (@skipped);
    }
    if (@no_pairs) {
        printf "\nMessages above threshold:\n";
        printf "%s\n", $_ foreach (@no_pairs);
    }
    printf "\nAll messages:\n";
    printf "%s\n", $_ foreach (keys %msg_hash);
    print "\n[OUTPUT] ";
}

if (@no_pairs) {
    my $num_msgs = (scalar @no_pairs > 1) ? "messages" : "message";
    $servicemessage = sprintf("CRITICAL: %d %s above threshold.",
        scalar @no_pairs, $num_msgs);
    $servicestatus = 2;
} else {
    my $num_msgs = (scalar keys %msg_hash > 1) ? "Messages" : "Message";
    $servicemessage = sprintf("OK: %s below threshold.", $num_msgs);
    $servicestatus = 0;
}

if ($opts{o}) {
    print $servicemessage . "\n";
} else {
    writecommand($commandhost, $commandsvc, $servicestatus, $servicemessage);
}

exit $servicestatus;
